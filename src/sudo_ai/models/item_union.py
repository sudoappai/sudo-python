"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .messagecontent import MessageContent, MessageContentTypedDict
from .outputmessage import OutputMessage, OutputMessageTypedDict
from .toolcalloutput import ToolCallOutput, ToolCallOutputTypedDict
from pydantic import model_serializer
from sudo_ai.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from typing import Any, List, Union
from typing_extensions import NotRequired, TypeAliasType, TypedDict


class Item19TypedDict(TypedDict):
    call_id: str
    input: str
    name: str
    type: str
    id: NotRequired[Nullable[str]]


class Item19(BaseModel):
    call_id: str

    input: str

    name: str

    type: str

    id: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["id"]
        nullable_fields = ["id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item18TypedDict(TypedDict):
    call_id: str
    output: ToolCallOutputTypedDict
    type: str
    id: NotRequired[Nullable[str]]


class Item18(BaseModel):
    call_id: str

    output: ToolCallOutput

    type: str

    id: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["id"]
        nullable_fields = ["id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item17TypedDict(TypedDict):
    arguments: str
    id: str
    name: str
    server_label: str
    type: str
    approval_request_id: NotRequired[Nullable[str]]
    error: NotRequired[Nullable[str]]
    output: NotRequired[Nullable[str]]
    status: NotRequired[Nullable[str]]


class Item17(BaseModel):
    arguments: str

    id: str

    name: str

    server_label: str

    type: str

    approval_request_id: OptionalNullable[str] = UNSET

    error: OptionalNullable[str] = UNSET

    output: OptionalNullable[str] = UNSET

    status: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["approval_request_id", "error", "output", "status"]
        nullable_fields = ["approval_request_id", "error", "output", "status"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item16TypedDict(TypedDict):
    approval_request_id: str
    approve: bool
    type: str
    id: NotRequired[Nullable[str]]
    reason: NotRequired[Nullable[str]]


class Item16(BaseModel):
    approval_request_id: str

    approve: bool

    type: str

    id: OptionalNullable[str] = UNSET

    reason: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["id", "reason"]
        nullable_fields = ["id", "reason"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item15TypedDict(TypedDict):
    arguments: str
    id: str
    name: str
    server_label: str
    type: str


class Item15(BaseModel):
    arguments: str

    id: str

    name: str

    server_label: str

    type: str


class Item14TypedDict(TypedDict):
    id: str
    server_label: str
    tools: List[Any]
    type: str
    error: NotRequired[Nullable[str]]


class Item14(BaseModel):
    id: str

    server_label: str

    tools: List[Any]

    type: str

    error: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["error"]
        nullable_fields = ["error"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item13TypedDict(TypedDict):
    id: str
    output: str
    type: str
    status: NotRequired[Nullable[str]]


class Item13(BaseModel):
    id: str

    output: str

    type: str

    status: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["status"]
        nullable_fields = ["status"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item12TypedDict(TypedDict):
    action: Any
    call_id: str
    id: str
    status: str
    type: str


class Item12(BaseModel):
    action: Any

    call_id: str

    id: str

    status: str

    type: str


class Item11TypedDict(TypedDict):
    code: str
    container_id: str
    id: str
    outputs: List[Any]
    status: str
    type: str


class Item11(BaseModel):
    code: str

    container_id: str

    id: str

    outputs: List[Any]

    status: str

    type: str


class Item10TypedDict(TypedDict):
    id: str
    result: str
    status: str
    type: str


class Item10(BaseModel):
    id: str

    result: str

    status: str

    type: str


class Item9TypedDict(TypedDict):
    content: List[Any]
    id: str
    summary: List[Any]
    type: str
    encrypted_content: NotRequired[Nullable[str]]
    status: NotRequired[Nullable[str]]


class Item9(BaseModel):
    content: List[Any]

    id: str

    summary: List[Any]

    type: str

    encrypted_content: OptionalNullable[str] = UNSET

    status: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["encrypted_content", "status"]
        nullable_fields = ["encrypted_content", "status"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item8TypedDict(TypedDict):
    call_id: str
    output: ToolCallOutputTypedDict
    type: str
    id: NotRequired[Nullable[str]]
    status: NotRequired[Nullable[str]]


class Item8(BaseModel):
    call_id: str

    output: ToolCallOutput

    type: str

    id: OptionalNullable[str] = UNSET

    status: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["id", "status"]
        nullable_fields = ["id", "status"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item7TypedDict(TypedDict):
    arguments: str
    call_id: str
    name: str
    type: str
    id: NotRequired[Nullable[str]]
    status: NotRequired[Nullable[str]]


class Item7(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: str

    id: OptionalNullable[str] = UNSET

    status: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["id", "status"]
        nullable_fields = ["id", "status"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item6TypedDict(TypedDict):
    action: Any
    id: str
    status: str
    type: str


class Item6(BaseModel):
    action: Any

    id: str

    status: str

    type: str


class Item5TypedDict(TypedDict):
    call_id: str
    output: Any
    type: str
    acknowledged_safety_checks: NotRequired[Nullable[List[Any]]]
    id: NotRequired[Nullable[str]]
    status: NotRequired[Nullable[str]]


class Item5(BaseModel):
    call_id: str

    output: Any

    type: str

    acknowledged_safety_checks: OptionalNullable[List[Any]] = UNSET

    id: OptionalNullable[str] = UNSET

    status: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["acknowledged_safety_checks", "id", "status"]
        nullable_fields = ["acknowledged_safety_checks", "id", "status"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class Item4TypedDict(TypedDict):
    action: Any
    call_id: str
    id: str
    pending_safety_checks: List[Any]
    status: str
    type: str


class Item4(BaseModel):
    action: Any

    call_id: str

    id: str

    pending_safety_checks: List[Any]

    status: str

    type: str


class Item3TypedDict(TypedDict):
    id: str
    queries: List[Any]
    results: List[Any]
    status: str
    type: str


class Item3(BaseModel):
    id: str

    queries: List[Any]

    results: List[Any]

    status: str

    type: str


class Item2TypedDict(TypedDict):
    content: List[OutputMessageTypedDict]
    id: str
    role: str
    status: str
    type: str


class Item2(BaseModel):
    content: List[OutputMessage]

    id: str

    role: str

    status: str

    type: str


class Item1TypedDict(TypedDict):
    content: MessageContentTypedDict
    role: str
    status: str
    type: str


class Item1(BaseModel):
    content: MessageContent

    role: str

    status: str

    type: str


ItemUnionTypedDict = TypeAliasType(
    "ItemUnionTypedDict",
    Union[
        Item10TypedDict,
        Item1TypedDict,
        Item6TypedDict,
        Item18TypedDict,
        Item13TypedDict,
        Item2TypedDict,
        Item3TypedDict,
        Item19TypedDict,
        Item8TypedDict,
        Item16TypedDict,
        Item14TypedDict,
        Item15TypedDict,
        Item12TypedDict,
        Item5TypedDict,
        Item11TypedDict,
        Item9TypedDict,
        Item7TypedDict,
        Item4TypedDict,
        Item17TypedDict,
    ],
)


ItemUnion = TypeAliasType(
    "ItemUnion",
    Union[
        Item10,
        Item1,
        Item6,
        Item18,
        Item13,
        Item2,
        Item3,
        Item19,
        Item8,
        Item16,
        Item14,
        Item15,
        Item12,
        Item5,
        Item11,
        Item9,
        Item7,
        Item4,
        Item17,
    ],
)
